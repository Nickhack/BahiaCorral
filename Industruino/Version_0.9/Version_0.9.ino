#include <SoftwareSerial.h> //libreria Serial
#include <DHT.h>
#include <SFE_BMP180.h>
#include <Wire.h>
#include <Arduino.h>
#include <U8g2lib.h>
#include <SPI.h>


U8G2_UC1701_MINI12864_1_4W_SW_SPI u8g2(U8G2_R2, 21, 20, 19, 22);   // rotation, clock, data, cs, dc

#define width 53
#define height 63
const static unsigned char u8g_logo_bits[] PROGMEM = {
   0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x02, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x08, 0xc2, 0xc5, 0xdd, 0xdd, 0xa5, 0x4e, 0x08, 0x42, 0x44, 0x84,
   0x54, 0xad, 0xa2, 0x08, 0xc2, 0xc5, 0x85, 0x4c, 0xbd, 0xa2, 0x08, 0x42,
   0x44, 0x84, 0x54, 0xb5, 0xe2, 0x08, 0xc2, 0xdd, 0x9d, 0xd4, 0xa5, 0xae,
   0x08, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x02, 0xff, 0xff, 0xff,
   0xff, 0x1f, 0x08, 0x02, 0x81, 0x00, 0x04, 0x00, 0x10, 0x08, 0x02, 0x81,
   0x00, 0x04, 0x00, 0x10, 0x08, 0x02, 0x81, 0x00, 0x04, 0x04, 0x10, 0x08,
   0x02, 0x81, 0x00, 0x04, 0x1e, 0x10, 0x08, 0x02, 0x81, 0x00, 0x04, 0x3e,
   0x10, 0x08, 0x02, 0xa1, 0x2d, 0x04, 0x3e, 0x10, 0x08, 0x02, 0xe1, 0x3f,
   0x04, 0x7e, 0x10, 0x08, 0x02, 0x21, 0x20, 0x04, 0x7f, 0x10, 0x08, 0x02,
   0x61, 0x26, 0x84, 0xff, 0x10, 0x08, 0x02, 0x71, 0x26, 0x84, 0xff, 0x10,
   0x08, 0x02, 0xb1, 0x20, 0xc4, 0xff, 0x10, 0x08, 0x02, 0xf1, 0x7f, 0xc4,
   0xff, 0x11, 0x08, 0x02, 0x11, 0x40, 0xc4, 0xff, 0x13, 0x08, 0x02, 0x11,
   0x40, 0xe4, 0xff, 0x11, 0x08, 0x02, 0x31, 0x40, 0xc4, 0xff, 0x11, 0x08,
   0x02, 0x11, 0x40, 0x84, 0xff, 0x10, 0x08, 0x02, 0x11, 0x40, 0x04, 0x1e,
   0x10, 0x08, 0x02, 0x31, 0x5c, 0x04, 0x1e, 0x10, 0x08, 0x02, 0x31, 0xde,
   0x04, 0x3e, 0x10, 0x08, 0x02, 0xfd, 0xff, 0xe4, 0xff, 0x13, 0x08, 0x02,
   0xff, 0xff, 0xff, 0xff, 0x1f, 0x08, 0x02, 0xff, 0xff, 0x07, 0x00, 0x10,
   0x08, 0x02, 0xf7, 0x7d, 0xa7, 0x02, 0x10, 0x08, 0x02, 0xe3, 0x38, 0xc6,
   0x03, 0x10, 0x08, 0x02, 0xf7, 0x7d, 0xc7, 0x2f, 0x10, 0x08, 0x02, 0xff,
   0xff, 0xc7, 0xff, 0x11, 0x08, 0x02, 0xf7, 0x7d, 0xc7, 0xff, 0x13, 0x08,
   0x02, 0xe3, 0x38, 0x06, 0xff, 0x17, 0x08, 0x02, 0xf7, 0x7d, 0x07, 0xff,
   0x17, 0x08, 0x02, 0xff, 0xff, 0x87, 0xff, 0x17, 0x08, 0x02, 0xf7, 0x7d,
   0x07, 0xfb, 0x13, 0x08, 0x02, 0xe3, 0x38, 0x06, 0x00, 0x10, 0x08, 0x02,
   0xf7, 0x7d, 0x07, 0x00, 0x10, 0x08, 0x02, 0xff, 0xff, 0x77, 0x01, 0x10,
   0x08, 0x02, 0xf7, 0x7d, 0xe7, 0x01, 0x10, 0x08, 0x02, 0xe3, 0x38, 0xf6,
   0x1f, 0x10, 0x08, 0x02, 0xf7, 0x7d, 0xe7, 0xff, 0x10, 0x08, 0x02, 0xff,
   0xff, 0xe7, 0xff, 0x11, 0x08, 0x02, 0xff, 0xff, 0xc7, 0xff, 0x13, 0x08,
   0x02, 0xff, 0xfd, 0x87, 0xff, 0x13, 0x08, 0x02, 0xff, 0xf8, 0xc7, 0xff,
   0x1b, 0x08, 0x02, 0xfe, 0xfd, 0x47, 0xf5, 0x0c, 0x08, 0x02, 0xfc, 0xff,
   0x07, 0x00, 0x06, 0x08, 0x02, 0xf8, 0xff, 0xff, 0xff, 0x03, 0x08, 0x02,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x06, 0x00, 0x92, 0xb9, 0x04, 0x00,
   0x0c, 0x0c, 0x00, 0x52, 0x8a, 0x04, 0x00, 0x06, 0x18, 0x00, 0xd2, 0x8b,
   0x07, 0x00, 0x03, 0x30, 0x00, 0x4c, 0xba, 0x04, 0x80, 0x01, 0x60, 0x00,
   0x00, 0x00, 0x00, 0xc0, 0x00, 0xc0, 0xff, 0xff, 0xfb, 0xff, 0x7f, 0x00,
   0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

#define Sin_nombre_width 80
#define Sin_nombre_height 63
const static unsigned char Sin_nombre_bits[] PROGMEM = {
   0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x80, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xe0, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff,
   0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0x3f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x3f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xfe, 0x2f, 0x7a, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x0f, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x07, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
   0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x07, 0x00, 0x80, 0x01,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x13, 0x00, 0x80, 0x01, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x80, 0xff, 0x01, 0x82, 0x01, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x80, 0xff, 0xc7, 0x9f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0xcf, 0xe7, 0xbb, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0x83,
   0x81, 0x03, 0x00, 0x10, 0x00, 0x00, 0x00, 0xc0, 0xfe, 0xc3, 0x07, 0x03,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf4, 0x81, 0x0b, 0x03, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xc0, 0xf0, 0x00, 0x01, 0x03, 0x00, 0x10, 0x00, 0x00,
   0x00, 0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x80, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x02,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0x07, 0x01, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x3f, 0x02, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x80, 0xf0, 0x03, 0x06, 0x00, 0x00, 0x10, 0x00, 0x00,
   0x00, 0x80, 0xf0, 0x07, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
   0xf1, 0x02, 0x07, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x80, 0xf3, 0x00,
   0x0f, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x80, 0xb6, 0x03, 0x04, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xbf, 0x57, 0x04, 0x00, 0x00, 0x10,
   0x00, 0x00, 0x00, 0x80, 0x3f, 0x3f, 0x04, 0x00, 0x00, 0x08, 0x00, 0x00,
   0x00, 0x00, 0x7f, 0x3f, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
   0xff, 0x3f, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
   0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x80, 0x00, 0xff, 0xff, 0x01, 0x00,
   0x00, 0x08, 0x00, 0x00, 0x80, 0x40, 0xff, 0xff, 0x01, 0x00, 0x00, 0x18,
   0x00, 0x00, 0x80, 0xf9, 0xff, 0xff, 0x01, 0x00, 0x00, 0x18, 0x00, 0x00,
   0xe0, 0xff, 0xfe, 0xff, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0xe0, 0xff,
   0xfc, 0x7f, 0x00, 0x00, 0x00, 0x18, 0x00, 0xd0, 0xe0, 0xff, 0xfc, 0x3f,
   0xc0, 0x00, 0x00, 0x1c, 0x00, 0xf8, 0xe0, 0xff, 0xf8, 0x0f, 0xc0, 0x01,
   0x00, 0x1c, 0x00, 0xfc, 0xe0, 0xff, 0xf1, 0x07, 0xc0, 0x87, 0x00, 0x1c,
   0x00, 0xfe, 0xe3, 0xff, 0xc1, 0x03, 0xc0, 0xdf, 0x00, 0x1c, 0x84, 0x7f,
   0x20, 0xf8, 0x07, 0x00, 0xe0, 0xff, 0x01, 0x1c, 0x84, 0x3f, 0x00, 0xf0,
   0x0f, 0x00, 0xf0, 0xff, 0x00, 0x1c, 0xc4, 0x3f, 0x00, 0xe0, 0x3f, 0x00,
   0xf0, 0xff, 0x01, 0x1e, 0xfc, 0x1f, 0x00, 0xe0, 0xff, 0x01, 0xff, 0xff,
   0x20, 0x1e, 0xfc, 0x3f, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x60, 0x1e,
   0xfc, 0x1f, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xe1, 0x9f, 0xfc, 0x1f,
   0x00, 0xc0, 0xff, 0xff, 0xff, 0x3f, 0xc0, 0x9f, 0xfc, 0x0f, 0x00, 0xc0,
   0xff, 0xff, 0x7f, 0x14, 0xc0, 0x9f, 0xfe, 0x0f, 0x00, 0xc0, 0xff, 0xff,
   0x3f, 0x00, 0xc0, 0xbf, 0xfe, 0x4f, 0x00, 0xc0, 0xff, 0xff, 0x3f, 0x00,
   0x80, 0x9f, 0xff, 0x97, 0x00, 0xc0, 0xff, 0xff, 0xbf, 0x07, 0x80, 0xbf,
   0xff, 0xdf, 0x00, 0xc0, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x9f, 0xff, 0x7f,
   0x00, 0xc0, 0xff, 0xff, 0xbf, 0x0f, 0x00, 0xbf, 0xff, 0xbf, 0x02, 0xc0,
   0xff, 0xff, 0x7f, 0x02, 0x00, 0xde, 0xff, 0xbf, 0x06, 0xe0, 0xff, 0xff,
   0xff, 0x07, 0x00, 0x9c, 0xff, 0xff, 0x03, 0xe0, 0xff, 0xff, 0xff, 0x01,
   0x00, 0xf8, 0xff, 0xff, 0x07, 0xe0, 0xff, 0xff, 0xbf, 0x07, 0x00, 0xf8,
   0xff, 0x7f, 0x06, 0xe0, 0xff, 0xff, 0xff, 0x0f, 0x00, 0xf0, 0xff, 0xff,
   0x04, 0xf0, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xf0, 0xff, 0xdf, 0x05, 0xfc,
   0xff, 0xff, 0xff, 0x0f, 0x00, 0xe0 };
#define Send_svg_width 64
#define Send_svg_height 64
const static unsigned char Send_svg_bits[] PROGMEM = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x1f,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0x07,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00,
   0x80, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0x01,
   0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x80,
   0xff, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0x9f, 0x7f, 0x00,
   0x00, 0x00, 0x00, 0xfc, 0xff, 0xc7, 0x7f, 0x00, 0x00, 0x00, 0x80, 0xff,
   0xff, 0xf1, 0x3f, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xf8, 0x3f, 0x00,
   0x00, 0x00, 0xfe, 0xff, 0x1f, 0xfc, 0x1f, 0x00, 0x00, 0x80, 0xff, 0xff,
   0x0f, 0xff, 0x0f, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x83, 0xff, 0x0f, 0x00,
   0x00, 0xfc, 0xff, 0xff, 0xc0, 0xff, 0x07, 0x00, 0xc0, 0xff, 0xff, 0x3f,
   0xf0, 0xff, 0x03, 0x00, 0xf0, 0xff, 0xff, 0x0f, 0xf8, 0xff, 0x03, 0x00,
   0xfe, 0xff, 0xff, 0x03, 0xfc, 0xff, 0x01, 0x00, 0xff, 0xff, 0xff, 0x01,
   0xff, 0xff, 0x01, 0x00, 0xff, 0xff, 0x3f, 0x80, 0xff, 0xff, 0x00, 0x00,
   0xfe, 0xff, 0x1f, 0xc0, 0xff, 0xff, 0x00, 0x00, 0xfc, 0xff, 0x07, 0xf0,
   0xff, 0x7f, 0x00, 0x00, 0xf0, 0xff, 0x01, 0xf8, 0xff, 0x7f, 0x00, 0x00,
   0xe0, 0x7f, 0x00, 0xfe, 0xff, 0x3f, 0x00, 0x00, 0xc0, 0x1f, 0x00, 0xff,
   0xff, 0x1f, 0x00, 0x00, 0x00, 0x07, 0x80, 0xff, 0xff, 0x1f, 0x00, 0x00,
   0x00, 0x00, 0xc0, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff,
   0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x07, 0x00, 0x00,
   0x00, 0x00, 0xfe, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
   0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00,
   0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
   0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
   0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfc, 0x1f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x7f, 0xf8, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe0,
   0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x07, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x03, 0x80, 0x07, 0x00, 0x00, 0x00 };

#define profe1_width 64
#define profe1_height 59
const static unsigned char profe1_bits[]PROGMEM = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
   0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0xc0, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x30, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00,
   0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x03, 0x00, 0x00,
   0x00, 0x00, 0x0c, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00,
   0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x05, 0x04, 0x00, 0x00,
   0x00, 0x00, 0xcc, 0x0f, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x0c,
   0x05, 0x04, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x0f, 0x0f, 0x06, 0x00, 0x00,
   0x00, 0x00, 0xcc, 0x0f, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x08, 0x06,
   0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x02, 0x00, 0x00,
   0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x02, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
   0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc,
   0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x20, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x40, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04,
   0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x16, 0x18, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x60, 0xf9, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xfa,
   0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x54, 0x00, 0x04, 0x00, 0x00,
   0x00, 0x00, 0x7f, 0xf8, 0x06, 0x04, 0x00, 0x00, 0x00, 0xc0, 0xfd, 0xf0,
   0x1f, 0x04, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xfc, 0x3f, 0x05, 0x01, 0x00,
   0x00, 0xfc, 0xff, 0xfd, 0x3f, 0x02, 0x10, 0x00, 0x80, 0xff, 0xff, 0xff,
   0x8f, 0x21, 0x10, 0x00, 0xa0, 0xfd, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x01,
   0xf0, 0xff, 0xff, 0xf7, 0x8f, 0x20, 0x10, 0x01, 0x70, 0xfd, 0xf6, 0xf7,
   0x1f, 0x00, 0x80, 0x09, 0xf8, 0xaf, 0xef, 0xff, 0x47, 0x10, 0x80, 0x09,
   0xf8, 0x7c, 0xad, 0xff, 0x0f, 0x10, 0x90, 0x0b, 0xfe, 0xab, 0x56, 0xff,
   0x1f, 0x20, 0xa0, 0x09, 0xfe, 0x5a, 0xad, 0xfe, 0x0f, 0x10, 0x00, 0x0f,
   0xfe, 0xaa, 0xaa, 0xff, 0x07, 0x10, 0x20, 0x09, 0xfe, 0x55, 0x2d, 0xfd,
   0x05, 0x10, 0x40, 0x02, 0xff, 0x34, 0x55, 0xfd, 0x05, 0x00, 0x40, 0x00,
   0xff, 0x65, 0x49, 0xfa, 0x05, 0x10, 0x00, 0x04, 0xff, 0x9a, 0x2a, 0xfd,
   0x07, 0x10, 0x80, 0x40, 0xff, 0xb5, 0x4a, 0x68, 0x0d, 0x10, 0x00, 0x09,
   0xff, 0x5b, 0x95, 0xd2, 0x15, 0x14, 0x00, 0x28, 0xff, 0xbf, 0x2a, 0x54,
   0x01, 0x19, 0x00, 0x2d, 0xff, 0x7b, 0x57, 0xe9, 0x0a, 0x14, 0x00, 0x3c,
   0xff, 0xff, 0x2a, 0x55, 0x09, 0x14, 0x00, 0x3c, 0xff, 0xbf, 0x55, 0x50,
   0x21, 0x08, 0x00, 0x1c };

#define profe2_width 64
#define profe2_height 58
const static unsigned char profe2_bits[] PROGMEM= {
   0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
   0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x3f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x1f,
   0xe0, 0x01, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x03, 0xc0, 0x03, 0x00, 0x00,
   0x00, 0x00, 0xe0, 0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x01,
   0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x0e, 0x00, 0x00,
   0x00, 0x00, 0xf0, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00,
   0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x3e, 0x00, 0x00,
   0x00, 0x00, 0x70, 0x08, 0x10, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x70, 0x3e,
   0x3c, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x70, 0x78, 0x0c, 0x1c, 0x00, 0x00,
   0x00, 0x00, 0x78, 0x78, 0x3c, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x70, 0x1a,
   0x2c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x0c, 0x00, 0x00,
   0x00, 0x00, 0x20, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
   0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x01, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc,
   0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x1c, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x08, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01,
   0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x04, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xbc, 0x02, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
   0x07, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x40, 0xe8, 0x01, 0x2f, 0x00, 0x00,
   0x00, 0x00, 0x40, 0x00, 0x00, 0xae, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00,
   0x00, 0x3e, 0x01, 0x00, 0x00, 0x00, 0x7d, 0x08, 0x00, 0x7e, 0x01, 0x00,
   0x00, 0x40, 0x7f, 0x20, 0x00, 0xff, 0x03, 0x00, 0x00, 0xe0, 0x7f, 0xe0,
   0x01, 0xff, 0x0f, 0x00, 0x00, 0xfe, 0xff, 0xf8, 0x81, 0xff, 0x3f, 0x00,
   0x80, 0xff, 0xff, 0xfd, 0xc1, 0xff, 0xff, 0x01, 0xe0, 0xff, 0xff, 0xff,
   0xe3, 0xff, 0xff, 0x03, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,
   0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xf8, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x1f, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f,
   0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xfe, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x3f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f,
   0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xfe, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff, 0x7f,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff, 0x7f };

#define estacion_width 64
#define estacion_height 65
const static unsigned char estacion_bits[] PROGMEM = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x20, 0x00, 0x02, 0x00, 0x0f, 0x00,
   0x00, 0x28, 0x00, 0x00, 0x82, 0xc8, 0x1c, 0x00, 0xc0, 0xab, 0x38, 0x00,
   0x1e, 0x8d, 0x0c, 0x00, 0x00, 0x30, 0x40, 0x08, 0x7c, 0x88, 0x0c, 0x00,
   0x00, 0x30, 0x00, 0x00, 0x10, 0x84, 0x09, 0x00, 0x00, 0x30, 0x00, 0x00,
   0x00, 0x84, 0x03, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0xcc, 0x03, 0x00,
   0x00, 0x70, 0x15, 0x00, 0x00, 0xf8, 0x01, 0x00, 0x00, 0xe0, 0x1f, 0x00,
   0x00, 0xa8, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x00, 0x00, 0x90, 0x00, 0x00,
   0x00, 0x80, 0x04, 0x00, 0x00, 0x78, 0x0b, 0x00, 0x00, 0xd0, 0x00, 0x00,
   0x00, 0x68, 0x7f, 0x00, 0x00, 0xad, 0x03, 0x00, 0x00, 0xd8, 0xd2, 0xff,
   0x7f, 0x55, 0x06, 0x00, 0x00, 0xa0, 0xad, 0x28, 0x45, 0x55, 0x01, 0x00,
   0x00, 0x00, 0x50, 0x6b, 0x29, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf2,
   0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x00, 0x00, 0x00,
   0xc0, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x60,
   0x01, 0x48, 0x01, 0x00, 0x70, 0x00, 0x01, 0x80, 0x01, 0x0c, 0x08, 0x00,
   0x78, 0x00, 0x01, 0x20, 0x01, 0x2e, 0x01, 0x00, 0x78, 0x00, 0x00, 0xa0,
   0x01, 0xfe, 0x3f, 0x00, 0x78, 0x00, 0x01, 0x20, 0x01, 0x1e, 0x10, 0x00,
   0x78, 0x00, 0x01, 0x60, 0x01, 0x0e, 0x00, 0x00, 0x78, 0x00, 0x01, 0x60,
   0x01, 0xfe, 0x1f, 0x00, 0x78, 0x00, 0x01, 0xa0, 0x01, 0x1e, 0x10, 0x00,
   0x78, 0x00, 0x01, 0xe0, 0x01, 0x0e, 0x10, 0x00, 0x78, 0x00, 0x00, 0xa0,
   0x01, 0xfe, 0x1f, 0x00, 0x78, 0x00, 0x01, 0xe0, 0x01, 0x2e, 0x10, 0x00,
   0x78, 0x00, 0x01, 0xf0, 0x03, 0x0e, 0x00, 0x00, 0xf8, 0xbf, 0x02, 0xfc,
   0x03, 0xde, 0x1d, 0x00, 0xe0, 0x1f, 0xf0, 0xff, 0x03, 0x3e, 0x10, 0x00,
   0x80, 0x7f, 0xed, 0xff, 0x03, 0x06, 0x00, 0x00, 0x00, 0x00, 0xa2, 0xfe,
   0x03, 0xfe, 0x1d, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x03, 0x1e, 0x10, 0x00,
   0x00, 0x00, 0x00, 0xf0, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
   0x01, 0x5e, 0x15, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x01, 0xbe, 0x0c, 0x00,
   0x00, 0x00, 0x00, 0xe0, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,
   0x01, 0x2e, 0x08, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0xfe, 0x1b, 0x00,
   0x00, 0x00, 0x00, 0xa0, 0x01, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0,
   0x03, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x03, 0xf8, 0x0f, 0x00,
   0x00, 0x00, 0x00, 0xf8, 0x07, 0xb8, 0x07, 0x00, 0x00, 0x00, 0x00, 0xf8,
   0x1f, 0x3c, 0x02, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x02, 0x00,
   0x00, 0x00, 0x00, 0xf8, 0xff, 0x7f, 0x01, 0x00, 0x00, 0x00, 0x00, 0xf8,
   0xf5, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x01, 0xfd, 0x01, 0x00,
   0x00, 0x00, 0x00, 0xe0, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00 };

#define mal_width 64
#define mal_height 46
const static unsigned char mal_bits[]PROGMEM = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x40, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
   0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x01, 0x00, 0x00,
   0x00, 0x00, 0x80, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff,
   0xff, 0x0f, 0x00, 0x00, 0x00, 0xc0, 0xfb, 0xff, 0xff, 0x3f, 0x00, 0x00,
   0x00, 0xf8, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff,
   0xff, 0x7f, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
   0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0xfe, 0xff, 0xff,
   0xff, 0xff, 0x01, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00,
   0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0xfe, 0xff, 0xf1,
   0x0f, 0xff, 0x07, 0x00, 0x00, 0xfe, 0xff, 0xe0, 0x0f, 0xff, 0x07, 0x00,
   0x00, 0xfe, 0xff, 0xe0, 0x07, 0xfe, 0x07, 0x00, 0x00, 0xff, 0xff, 0xe0,
   0x0f, 0xff, 0x07, 0x00, 0xc0, 0xff, 0xff, 0xf1, 0x1f, 0xff, 0x0f, 0x00,
   0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0xf0, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x01, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03,
   0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0xfc, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x0f, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,
   0xfe, 0xff, 0xff, 0x07, 0xf0, 0xff, 0xff, 0x1f, 0xfc, 0xff, 0xff, 0x01,
   0x80, 0xff, 0xff, 0x1f, 0xfe, 0xff, 0xff, 0x41, 0x01, 0xff, 0xff, 0x1f,
   0xfe, 0xff, 0xff, 0xfb, 0x1f, 0xff, 0xff, 0x3f, 0xfc, 0xff, 0xff, 0xff,
   0x3f, 0xff, 0xff, 0x1f, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f,
   0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xfc, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x1f, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,
   0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xf0, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x07, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03,
   0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0xfc, 0xff, 0xff,
   0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
   
//Definir Pines
int WindVane=0;


#define ALTITUDE 37.0 // Altitud a las que esta puesto el Sensor

//Variables estacion meteorologica
float Grados;
int vientogrados;
float antes;

float viento;
float preduracion=0;

#define RAIN_FACTOR 0.2794
//long interval = 3600000; // Intervalo de 1 hora para medir la lluvia por hora
float Ppreduracion=0;
float conteolluvia=0;
float lluviainstante;
float lluviaporhora;
long previousMillis = 0;


//SSID + KEY
const char SSID_ESP[] = "Sr Oso";
const char SSID_KEY[] = "paralelepipedoosesno";

//
int tmuestreo=180; //tiempo entre muestreo partido por 5 en seg



//Iniciar Conexion Serial con el ESP8266
SoftwareSerial ESP8266(14, 4);//Se incia el ESP(Rxpin, Txpin)
DHT dht(7,DHT22);//Se inicia una variable que será usada por Arduino para comunicarse con el sensor(pin,tipo)
SFE_BMP180 pressure;


//Funciones a usar
boolean setup_ESP();
boolean read_until_ESP(const char keyword1[], int key_size, int timeout_val, byte mode);
void serial_dump_ESP();
boolean connect_ESP();
void get(char direccion[], int a);


//Variables Globales
unsigned long timeout_start_val;
char scratch_data_from_ESP[20];//first byte is the length of bytes
char payload[300];
byte payload_size=0, counter=0;
int error = 0;


//DEFINE KEYWORDS HERE
const char keyword_OK[] = "OK";
const char keyword_Ready[] = "ready";
const char keyword_quote[] = "\"";
const char keyword_carrot[] = ">";
const char keyword_sendok[] = "SEND OK";

void setup(){

  
  //Iniciar Serial para Debug
  Serial.begin(9600);
  u8g2.begin();

  //Se inicia el sensor DHT
  dht.begin();
  
  pinMode(26,OUTPUT);
  digitalWrite(26,LOW);
  //Se añaden las interrupcion y configuran los pins para la estacion meteorologica
  pinMode(WindVane,INPUT);

  pinMode(1, INPUT);
  digitalWrite(1,HIGH);
  attachInterrupt(3, vientovelocidad, FALLING);

  pinMode(0, INPUT_PULLUP);
  digitalWrite(0,HIGH);
  attachInterrupt(2, puvliometro, FALLING);
  
  u8g2.firstPage();
  do 
  {
    u8g2.drawXBMP( 0, 0, Sin_nombre_width, Sin_nombre_height, Sin_nombre_bits);
    u8g2.setFont(u8g2_font_timR08_tr);
    u8g2.drawStr(85,30,"Iniciando");
  } while ( u8g2.nextPage() );

  //reseteo de hw del esp
  pinMode(11,OUTPUT);
  digitalWrite(11,LOW);
  pinMode(11,INPUT);

  delay(5000);

  //Iniciamos el ESP
  ESP8266.begin(9600);
  //Se inicia BMP180
  pressure.begin();
  
  setup_ESP();//Configurar el ESP
}

void loop()
{
  String dir="GET /adb/carga.php?HR=";
  String dato1 = "";
  String dato2 = "";
  String dato3 = "";
  String dato4 = "";
  String dato5 = "";
  String dato6 = "";
  String dato7 = "";
  String dato8 = "";
  float h=0;
  float t=0;
  double T=0;
  double P=0;
  double p0=0;

  u8g2.firstPage();
  do {
    u8g2.setFont(u8g2_font_timR08_tr);
    u8g2.drawXBMP( 0, 0, estacion_width, estacion_height, estacion_bits);
    u8g2.drawStr(70,15,"Recuperando");
    u8g2.drawStr(70,25,"Datos");
  } while ( u8g2.nextPage() );

  delay(1000);

  //******************************Datos del DHT********************************
  h = dht.readHumidity(); //Se lee la humedad
  t = dht.readTemperature(); //Se lee la temperatura
  
  u8g2.firstPage();
  do {
    u8g2.setFont(u8g2_font_timR08_tr);
    u8g2.drawXBMP( 0, 0, estacion_width, estacion_height, estacion_bits);
    u8g2.drawStr(70,15,"Recuperando");
    u8g2.drawStr(70,25,"Datos");
    u8g2.drawStr(70,35,"DHT Ok");
  } while ( u8g2.nextPage() );

  delay(3000);
  
  //*******************************Datos de BMP180*****************************
  char status;
  
  // Primero debemos Calcular la temperatura
  // Si logra obtener la Temperatura nos devuelve el tiempo que debemos esperar, y si no un 0
  
  status = pressure.startTemperature();
  if (status != 0)
  {
    delay(status);
    // Si se pudo iniciar el proceso de obtener la temperatura esta se obtiene
    status = pressure.getTemperature(T);
    if (status != 0)
    {       
      // Se inicia el proceso de obtener la presion, el parametro es para el sobremuestro que deseamos 0 a 3(menos tiempo y menos presicion a mas tiempo y mas presicion
      status = pressure.startPressure(3);
      if (status != 0)
      {
        delay(status);
        // Si se pudo inciar el proceso de presion se obtiene la presion en P y cabe destacar que para este proceso se requiere la temperatura
        status = pressure.getPressure(P,T);
        if (status != 0)
        {
          // La presion retornada es la Absoluta, la cual varia dependiendo de la altitud, para remover este efecto usamos la funcion sealevel() 
          p0 = pressure.sealevel(P,ALTITUDE);
          u8g2.firstPage();
          do {
            u8g2.setFont(u8g2_font_timR08_tr);
            u8g2.drawXBMP( 0, 0, estacion_width, estacion_height, estacion_bits);
            u8g2.drawStr(70,15,"Recuperando");
            u8g2.drawStr(70,25,"Datos");
            u8g2.drawStr(70,35,"DHT Ok");
            u8g2.drawStr(70,45,"BMP Ok");
          } while ( u8g2.nextPage() );
        }
        else
        {
          Serial.println("Error obteniendo presion");
          do {
            u8g2.setFont(u8g2_font_timR08_tr);
            u8g2.drawXBMP( 0, 0, estacion_width, estacion_height, estacion_bits);
            u8g2.drawStr(70,15,"Recuperando");
            u8g2.drawStr(70,25,"Datos");
            u8g2.drawStr(70,35,"DHT Ok");
            u8g2.drawStr(70,45,"BMP F pre");
          } while ( u8g2.nextPage() );
        }
      }
      else
      {
        Serial.println("Error iniciando el proceso de Presion");
        do {
          u8g2.setFont(u8g2_font_timR08_tr);
          u8g2.drawXBMP( 0, 0, estacion_width, estacion_height, estacion_bits);
          u8g2.drawStr(70,15,"Recuperando");
          u8g2.drawStr(70,25,"Datos");
          u8g2.drawStr(70,35,"DHT Ok");
          u8g2.drawStr(70,45,"BMP F pre");
        } while ( u8g2.nextPage() );        
      }
    }
    else 
    {
      Serial.println("Error Obteniendo la Temperatura");
      do {
        u8g2.setFont(u8g2_font_timR08_tr);
        u8g2.drawXBMP( 0, 0, estacion_width, estacion_height, estacion_bits);
        u8g2.drawStr(70,15,"Recuperando");
        u8g2.drawStr(70,25,"Datos");
        u8g2.drawStr(70,35,"DHT Ok");
        u8g2.drawStr(70,45,"BMP F T");
      } while ( u8g2.nextPage() );
    }
  }
  else
  {
    Serial.println("Error Iniciando el Proceso de Temperatura");
    do {
      u8g2.setFont(u8g2_font_timR08_tr);
      u8g2.drawXBMP( 0, 0, estacion_width, estacion_height, estacion_bits);
      u8g2.drawStr(70,15,"Recuperando");
      u8g2.drawStr(70,25,"Datos");
      u8g2.drawStr(70,35,"DHT Ok");
      u8g2.drawStr(70,45,"BMP F T");
    } while ( u8g2.nextPage() );
  }

  
  delay(3000);

  //*******************************Calculo Direccion del vientos*****************************
  
  antes= analogRead(WindVane);
  Grados= ((antes*5)/1024);

  if(Grados <= 0.675)
  {
 //   Serial.println("  La direccion del viento es:");
 //   Serial.println("Este 90");
    vientogrados=90;
  }
  if(Grados > 0.675 && Grados <= 1.15)
  {
  //  Serial.println("  La direccion del viento es:");
  //  Serial.println("Sur Este 135");
    vientogrados=135;
  }
  if(Grados > 1.15 && Grados <= 1.825)
  {
  //  Serial.println("  La direccion del viento es:");
  //  Serial.println("Sur 180");
    vientogrados=180;
  }
  if(Grados > 1.825 && Grados <= 2.665)
  {
  //  Serial.println("  La direccion del viento es:");
  //  Serial.println("NorEste 45");
    vientogrados=45;
  }
  if(Grados > 2.665 && Grados <= 3.46)
  {
 //   Serial.println("  La direccion del viento es:");
  //  Serial.println("SurOeste 225");
    vientogrados=225;
  }
  if(Grados > 3.46 && Grados <= 4.23)
  {
  //  Serial.println("  La direccion del viento es:");
  //  Serial.println("Norte 0");
    vientogrados=0;
  }
  if(Grados > 4.59 && Grados <= 4.70)
  {
  //  Serial.println("  La direccion del viento es:");
    Serial.println("Oeste 270");
    vientogrados=270;
  }
  if(Grados > 4.30 && Grados <= 4.40)
  {
 //   Serial.println("  La direccion del viento es:");
//    Serial.println("NorOeste 315");
    vientogrados=315;
  }  

  //Calculo de LLuvia
  unsigned long currentMillis = millis();
  previousMillis = currentMillis;
    
  lluviaporhora=lluviainstante;
  lluviainstante=0;
  conteolluvia=0;
  
  float vientoaux=viento;
  
  /*Variables a entregar
  DHT
    Humedad relativa  -> h
    T°                -> t
  BMP180
    T°                -> T
    Presion Abs       -> P
    Presion Rel       -> p0

  Estacion
    Direccion         -> vientogrados
    Velocidad         -> vientoaux
    Precipitacion     -> lluviaporhora
    
*/



  //Manejo Cadena de GET
  dir = dir + h + "&TDHT=" + t + "&TBMP=" + T + "&PABS=" + P + "&PREL=" + p0 + "&DIR=" + vientogrados + "&VEL=" + vientoaux + "&LLUVIA=" + lluviaporhora + " HTTP/1.0\r\n\r\n";
  char ssid[dir.length()+1];
  dir.toCharArray(ssid, dir.length()+1);

  
  if(error==0)
  {
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_timR08_tr);
      u8g2.drawXBMP( 0, 0, Send_svg_width, Send_svg_height, Send_svg_bits);
      u8g2.drawStr(80,35,"Enviando...");
    } while( u8g2.nextPage() );

    get(ssid,sizeof(ssid));
    delay(3000);

    if(error==0)
    {

      dato1 = dato1 + "HR = " + h;
      char dato1aux[dato1.length()+1];
      dato1.toCharArray(dato1aux, dato1.length()+1);
    
      dato2 = dato2 + "T1 = " + t;
      char dato2aux[dato2.length()+1];
      dato2.toCharArray(dato2aux, dato2.length()+1);
    
      dato3 = dato3 + "T2 = " + T;
      char dato3aux[dato3.length()+1];
      dato3.toCharArray(dato3aux, dato3.length()+1);
    
      dato4 = dato4 + "Pab = " + P;
      char dato4aux[dato4.length()+1];
      dato4.toCharArray(dato4aux, dato4.length()+1);
    
      dato5 = dato5 + "Pre = " + p0;
      char dato5aux[dato5.length()+1];
      dato5.toCharArray(dato5aux, dato5.length()+1);
    
      dato6 = dato6 + "Dir = " + vientogrados;
      char dato6aux[dato6.length()+1];
      dato6.toCharArray(dato6aux, dato6.length()+1);
    
      dato7 = dato7 + "Vel = " + vientoaux;
      char dato7aux[dato7.length()+1];
      dato7.toCharArray(dato7aux, dato7.length()+1);
    
      dato8 = dato8 + "Llu = " + lluviaporhora;
      char dato8aux[dato8.length()+1];
      dato8.toCharArray(dato8aux, dato8.length()+1);

      int trestante=0;
      String cadfin = "";
      
      for(int i=0;i<tmuestreo;i++)
      {
        cadfin = "";
        trestante=(tmuestreo*5)-(i*5);
        cadfin = cadfin + "Prox. Envio " + trestante + "seg";
        char cadfinaux[cadfin.length()+1];
        cadfin.toCharArray(cadfinaux, cadfin.length()+1);
         
        u8g2.firstPage();
        do 
        {
          u8g2.setFont(u8g2_font_profont10_mf);
          u8g2.drawFrame(0,0,128,64);
          u8g2.drawFrame(1,1,126,62);
          
          u8g2.drawStr(3,10,"Datos Rescatados :");
          u8g2.drawStr(3,20,dato1aux);
          u8g2.drawStr(60,20,dato2aux);
          u8g2.drawStr(3,30,dato3aux);
          u8g2.drawStr(60,30,dato4aux);
          u8g2.drawStr(3,40,dato6aux);
          u8g2.drawStr(60,40,dato5aux);
          u8g2.drawStr(3,50,dato7aux);
          u8g2.drawStr(60,50,dato8aux);    
      

          u8g2.drawStr(3,60,cadfinaux);
          
          u8g2.drawFrame(0,12,58,41);
          u8g2.drawFrame(0,12,127,41);
  
          
        } while ( u8g2.nextPage() );
        delay(5000);
      }
      
      
    }else
    {//Error en el envio de datos

      u8g2.firstPage();
      do {
        u8g2.setFont(u8g2_font_timR08_tr);
        u8g2.drawXBMP( 0, 10, mal_width, mal_height, mal_bits);
        u8g2.drawStr(70,25,"Problemas Al Enviar");
        u8g2.drawStr(70,35,"Ejecutando Setup()...");
        delay(4000);
        error=0;
        setup_ESP();        
      } while( u8g2.nextPage() );
       
    }

  }else
  {//Error en el Setup() Se volvera a configurar para el proximo inicio

    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_timR08_tr);
      u8g2.drawXBMP( 0, 10, mal_width, mal_height, mal_bits);
      u8g2.drawStr(70,25,"Falla Configuracion");
      u8g2.drawStr(70,35,"Ejecutando Setup()...");
    } while( u8g2.nextPage() );
    delay(4000);
    error=0;
    setup_ESP();
  }


  //Reset del Arduino para prevenir Overflow de millis();
  if(millis()>864000000)
  {
    Serial.println("Reseteando....");
    delay(3000);
    pinMode(13,OUTPUT);
    digitalWrite(13,LOW);
  }
  
 // delay(53000);//delay para el tiempo de cada toma de datos
}

//Configura el Modulo ESP8266 con comandos AT
boolean setup_ESP()
{ //Comprueba comunicacion con un AT

  int at=0,atrst=0,atcwmode=0,atcwjap=0,atcipmux=0;

  //reseteo de hw del esp
  pinMode(11,OUTPUT);
  digitalWrite(11,LOW);
  pinMode(11,INPUT);

  delay(5000);
  
  ESP8266.print("AT\r\n");
  if(read_until_ESP(keyword_OK,sizeof(keyword_OK),5000,0))
  {
    Serial.println("Comunicacion con ESP OK");
    at=1;
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_timR08_tr);
      u8g2.drawXBMP( 0, 0, width, height, u8g_logo_bits);
      u8g2.drawStr(55,10,"Comunicacion OK");
    } while ( u8g2.nextPage() );
  }
  else
  {
    Serial.println("Problemas de comunicacion con el ESP");
    at=2;
    error=1;
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_timR08_tr);
      u8g2.drawXBMP( 0, 0, width, height, u8g_logo_bits);
      u8g2.drawStr(55,10,"Comunicacion X");
    } while ( u8g2.nextPage() );
  } 
  
  serial_dump_ESP();

  //Aplica un reset al ESP
  ESP8266.print("AT+RST\r\n");
  if(read_until_ESP(keyword_Ready,sizeof(keyword_Ready),10000,0))
  {
    Serial.println("ESP Reseteado");
    atrst=1;
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_timR08_tr);
      u8g2.drawXBMP( 0, 0, width, height, u8g_logo_bits);
      if(at==1)
        u8g2.drawStr(55,10,"Comunicacion OK");
      if(at==2)
        u8g2.drawStr(55,10,"Comunicacion X");

      u8g2.drawStr(55,20,"Reset OK");
    } while ( u8g2.nextPage() );
  }
  else
  {
    Serial.println("ESP Problemas al Resetear"); 
    atrst=2;
    error=1;
    
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_timR08_tr);
      u8g2.drawXBMP( 0, 0, width, height, u8g_logo_bits);
      if(at==1)
        u8g2.drawStr(55,10,"Comunicacion OK");
      if(at==2)
        u8g2.drawStr(55,10,"Comunicacion X");

      u8g2.drawStr(55,20,"Reset X");
    } while ( u8g2.nextPage() );    
  }
    
  serial_dump_ESP();
  
  //Configura CWMODE
  ESP8266.print("AT+CWMODE=1\r\n");
  if(read_until_ESP(keyword_OK,sizeof(keyword_OK),1000,0))
  {
    Serial.println("Configurado CWMODE");
    atcwmode=1;
        u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_timR08_tr);
      u8g2.drawXBMP( 0, 0, width, height, u8g_logo_bits);
      if(at==1)
        u8g2.drawStr(55,10,"Comunicacion OK");
      if(at==2)
        u8g2.drawStr(55,10,"Comunicacion X");
      if(atrst==1)
        u8g2.drawStr(55,20,"Reset OK");
      if(atrst==2)
        u8g2.drawStr(55,20,"Reset X");
        
      u8g2.drawStr(55,30,"CWMODE OK");
    } while ( u8g2.nextPage() );
    
  }
  else
  {
    Serial.println("Problemas Configurando el MODE");
    atcwmode=2;
    error=1;
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_timR08_tr);
      u8g2.drawXBMP( 0, 0, width, height, u8g_logo_bits);
      if(at==1)
        u8g2.drawStr(55,10,"Comunicacion OK");
      if(at==2)
        u8g2.drawStr(55,10,"Comunicacion X");
      if(atrst==1)
        u8g2.drawStr(55,20,"Reset OK");
      if(atrst==2)
        u8g2.drawStr(55,20,"Reset X");
        
      u8g2.drawStr(55,30,"CWMODE X");
    } while ( u8g2.nextPage() );
        
  }
  
  serial_dump_ESP();  
   
  //Se tratara de conectar a la red con SSID y PSWD Correspondiente
  ESP8266.print("AT+CWJAP=\"");
  ESP8266.print(SSID_ESP);
  ESP8266.print("\",\"");
  ESP8266.print(SSID_KEY);
  ESP8266.print("\"\r\n");
  if(read_until_ESP(keyword_OK,sizeof(keyword_OK),10000,0))
  {
    Serial.println("Conectado a Red Wifi");
    atcwjap=1;
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_timR08_tr);
      u8g2.drawXBMP( 0, 0, width, height, u8g_logo_bits);
      if(at==1)
        u8g2.drawStr(55,10,"Comunicacion OK");
      if(at==2)
        u8g2.drawStr(55,10,"Comunicacion X");
      if(atrst==1)
        u8g2.drawStr(55,20,"Reset OK");
      if(atrst==2)
        u8g2.drawStr(55,20,"Reset X");
      if(atcwmode==1)
        u8g2.drawStr(55,30,"CWMODE OK");
      if(atcwmode==2)
        u8g2.drawStr(55,30,"CWMODE X");

      u8g2.drawStr(55,40,"WIFI OK");
    } while ( u8g2.nextPage() );
  }
  else
  {
    Serial.println("Problemas al Conectar a Red Wifi");
    atcwjap=2;
    error=1;
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_timR08_tr);
      u8g2.drawXBMP( 0, 0, width, height, u8g_logo_bits);
      if(at==1)
        u8g2.drawStr(55,10,"Comunicacion OK");
      if(at==2)
        u8g2.drawStr(55,10,"Comunicacion X");
      if(atrst==1)
        u8g2.drawStr(55,20,"Reset OK");
      if(atrst==2)
        u8g2.drawStr(55,20,"Reset X");
      if(atcwmode==1)
        u8g2.drawStr(55,30,"CWMODE OK");
      if(atcwmode==2)
        u8g2.drawStr(55,30,"CWMODE X");

      u8g2.drawStr(55,40,"WIFI X");
    } while ( u8g2.nextPage() );
  }

  serial_dump_ESP();
  
  //Configura el CIPMUX
  ESP8266.print("AT+CIPMUX=1\r\n");
  if(read_until_ESP(keyword_OK,sizeof(keyword_OK),5000,0))
  {
    Serial.println("Configurado CIPMUX");
    atcipmux=1;
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_timR08_tr);
      u8g2.drawXBMP( 0, 0, width, height, u8g_logo_bits);
      if(at==1)
        u8g2.drawStr(55,10,"Comunicacion OK");
      if(at==2)
        u8g2.drawStr(55,10,"Comunicacion X");
      if(atrst==1)
        u8g2.drawStr(55,20,"Reset OK");
      if(atrst==2)
        u8g2.drawStr(55,20,"Reset X");
      if(atcwmode==1)
        u8g2.drawStr(55,30,"CWMODE OK");
      if(atcwmode==2)
        u8g2.drawStr(55,30,"CWMODE X");
      if(atcwjap==1)
        u8g2.drawStr(55,40,"WIFI OK");
      if(atcwjap==2)
        u8g2.drawStr(55,40,"WIFI X");
        
      u8g2.drawStr(55,50,"CIPMUX OK");
    } while ( u8g2.nextPage() );
  }
  else
  {
    Serial.println("Problemas al Configurar CIPMUX");
    atcipmux=2;
    error=1;
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_timR08_tr);
      u8g2.drawXBMP( 0, 0, width, height, u8g_logo_bits);
      if(at==1)
        u8g2.drawStr(55,10,"Comunicacion OK");
      if(at==2)
        u8g2.drawStr(55,10,"Comunicacion X");
      if(atrst==1)
        u8g2.drawStr(55,20,"Reset OK");
      if(atrst==2)
        u8g2.drawStr(55,20,"Reset X");
      if(atcwmode==1)
        u8g2.drawStr(55,30,"CWMODE OK");
      if(atcwmode==2)
        u8g2.drawStr(55,30,"CWMODE X");
      if(atcwjap==1)
        u8g2.drawStr(55,40,"WIFI OK");
      if(atcwjap==2)
        u8g2.drawStr(55,40,"WIFI X");
        
      u8g2.drawStr(55,50,"CIPMUX X");
    } while ( u8g2.nextPage() );    
    
  }
    
  serial_dump_ESP();

  delay(3000);
}


//Funcion simple que elimina toda la basura que queda en el buffer
void serial_dump_ESP()
{
  char temp;
  while(ESP8266.available())
  {
    temp =ESP8266.read();
    delay(10);//Si el bufer se esta sobrecargando variar este delay
  }//while
}//serial dump


//Esta Funcion recibe una palabra, la busca y retorna un 1 cuando la encuentra
// const char keyword1[] = La palablra 
// int key_size = El tamaño de la palabra
// int timeout_val - Tiempo para buscar la palabra
// byte mode - si es 1 almacena toda la informacion obtenida como respuesta

boolean read_until_ESP(const char keyword1[], int key_size, int timeout_val, byte mode)
{
  timeout_start_val=millis();
  char data_in[20];//Este es el bufer para ir guardando si lo que se busca es mayor a 20 incrementar esto
  int scratch_length=1;//El largo del arreglo de datos
  key_size--;//se elimina el caracter extra entregado por sizeof()
 
 //LLenado del BUFFER
 for(byte i=0; i<key_size; i++)
 {//Solo se nesecita un bufer tan largo como la palabra buscada
    //Controla el tiempo de espera indicado por una respuesta
    while(!ESP8266.available())
    {
       if((millis()-timeout_start_val)>timeout_val)
       {
           Serial.println("timeout1");
           return 0;
        }
    }
   
    data_in[i]=ESP8266.read();// Guarda el byte el el Buffer

    if(mode==1)
    {//Guarda la informacion
      scratch_data_from_ESP[scratch_length]=data_in[i];
      scratch_data_from_ESP[0]=scratch_length;// [0] es usado para almacenar el largo de la informacion
      scratch_length++;
    }
    
  }
  
//THE BUFFER IS FULL, SO START ROLLING NEW DATA IN AND OLD DATA OUT
  while(1)
  {//stay in here until the keyword found or a timeout occurs
    for(byte i=0; i<key_size; i++)
    {
       if(keyword1[i]!=data_in[i])//if it doesn't match, break out of the search now
         break;//get outta here
       if(i==(key_size-1))
       {//encontramos todo el largo de la palabra retornamos un 1
         return 1;
       }
    }
    //start rolling the buffer
    for(byte i=0; i<(key_size-1); i++)
    {// keysize-1 because everthing is shifted over - see next line
      data_in[i]=data_in[i+1];// so the data at 0 becomes the data at 1, and so on.... the last value is where we'll put the new data
    }//for
 
         
           //timing control
            while(!ESP8266.available()){// same thing as done in the buffer
              if((millis()-timeout_start_val)>timeout_val){
                Serial.println("timeout2");
                return 0;
              }//timeout
            }// while !avail
    
   
   
    data_in[key_size-1]=ESP8266.read();//save the new data in the last position in the buffer
   
      if(mode==1){//continue to save everything if thsi is set
      scratch_data_from_ESP[scratch_length]=data_in[key_size-1];
      scratch_data_from_ESP[0]=scratch_length;
      scratch_length++;
    }//mode 1
  }//while 1
}

//Funcion para manejar la informacion a enviar y el tamaño de esta
void get(char direccion[], int a)
{
  counter=0;
  payload_size=0;
  for(int i=0; i<a-1; i++)
  {//Recorremos la direccion completa para calcular su tamaño y ubicarla en el arreglo de envio de informacion
    payload[payload_size+i] = direccion[i];
    counter++;//increment the counter
  }
  //Asignamos el tamaño de la informacion
  payload_size = counter+payload_size;

  //Se llama la conexion y envio de datos
  connect_ESP();
  
  serial_dump_ESP();

}


//Se conecta al Servidor y envia la informacion con Comandos AT
boolean connect_ESP()
{
  //Comando AT Para inciar la conexion al servidor
  Serial.println("Conectando");
  ESP8266.print("AT+CIPSTART=0,\"TCP\",\"54.186.50.8\",80\r\n");//Servidor
  if(read_until_ESP(keyword_OK,sizeof(keyword_OK),5000,0))
  { //Si encontramos al OK
    serial_dump_ESP();
    //Comando AT para iniciar la conexion TCP con el tamaño de la carga a enviar
    Serial.println("Conectado");
    ESP8266.print("AT+CIPSEND=0,");
    ESP8266.print(payload_size);
  
    serial_dump_ESP();
  
    ESP8266.print("\r\n");//Para terminar el comando anterior
  
    if(read_until_ESP(keyword_carrot,sizeof(keyword_carrot),10000,0))
    { //Si nos entrega el > Esta listo para recibir la informacion a enviar
      Serial.println("Listo Para Enviar");
      for(int i=0; i<payload_size; i++)
      {//Envio de la Informacion
        ESP8266.print(payload[i]);
      }
    
      if(read_until_ESP(keyword_sendok,sizeof(keyword_sendok),10000,0))
      {//Esperamos el SEND OK
        Serial.println("Envio Completo");
        error=0;
        return 1;
      }
      else
      {
        Serial.println("Falla en el Envio");
        error=2;
      }
        
  
    }
    else
    {
      Serial.println("Falla al Obtener >");
      error=2;
    }
      
  
  }
  else
  {
     Serial.println("Falla en la Conexion");
     error=2;
  }
}


void vientovelocidad()
{ 
  float duracion=millis()-preduracion;
  preduracion=millis();
  if(duracion>6)
  {
    viento=2.4/(duracion/1000);
  }  
}

void puvliometro()
{ 
  float Pduracion=millis()-Ppreduracion;
  Ppreduracion=millis();
  if(Pduracion>10)
  {
    conteolluvia++;
  }
  lluviainstante= (conteolluvia)*RAIN_FACTOR;
}
